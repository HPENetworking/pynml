{%- macro param_attrs(attrs) -%}
{% if attrs -%}
, {% for attr in attrs -%}
{{ attr.name|variablize }}={{ attr.default_arg }}
{%- if not loop.last %}, {% endif -%}
{%- endfor %}
{%- endif %}
{%- endmacro -%}
# -*- coding: utf-8 -*-
#
# Copyright (C) 2015-2018 Hewlett Packard Enterprise Development LP
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

"""
pynml main module.

.. warning::

   This file is autogenerated. DO NOT EDIT!
   To generate this file, edit the spec.py file.
"""

from copy import copy
from datetime import datetime
from collections import OrderedDict
from abc import ABCMeta, abstractmethod
from xml.etree import ElementTree as etree  # noqa

from rfc3986 import is_valid_uri

from .exceptions import (
    {%- for exc in exceptions %}
    {{ exc }}{% if not loop.last %},{% endif %}
    {%- endfor %}
)


# Register XML namespaces
NAMESPACES = {'nml': 'http://schemas.ogf.org/nml/2013/05/base'}
for xmlns, uri in NAMESPACES.items():
    etree.register_namespace(xmlns, uri)

# Special unique variable for unset values
unset = type(str('Unset'), (object,), {})()


class NMLObject(metaclass=ABCMeta):
    """
    Base object for every NML object.

    This object is not part of the specification, it is just 'Pure Fabrication'
    (see GRASP) of refactored functionality of all objects.
    """

    @abstractmethod
    def __init__(self, **kwargs):
        self.attributes = []
        self.relations = OrderedDict()
        self.metadata = kwargs

    def _describe_object(self):
        """
        Describe and pretty-print the NML object.

        :return: A pretty-printed string with attributes and metadata.
        :rtype: str
        """
        name = self.__class__.__name__
        attributes = [
            (attr, getattr(self, attr))
            for attr in self.attributes + ['metadata']
            if hasattr(self, attr)
        ]
        formatted_attributes = ', '.join([
            '{}={}'.format(attr, repr(value)) for attr, value in attributes
        ])
        return '{}({})'.format(name, formatted_attributes)

    def __repr__(self):
        return self._describe_object()

    def __str__(self):
        return self._describe_object()

    def _tree_element(self, this, parent):
        """
        Helper function to identify an XML node to modify in a inheritance and
        multi-node tree.
        """
        if this is None:
            name = 'nml:' + self.__class__.__name__
            if parent is None:
                this = etree.Element(name)
            else:
                this = etree.SubElement(parent, name)
        return this

    def as_nml(self, this=None, parent=None):
        """
        Build NML representation of this node.

        :param this: Node to modify. If `None`, a new node is created.
        :type this: :py:class:`xml.etree.ElementTree`
        :param parent: Parent node to hook to. If `None`, a root node is
         created.
        :type parent: :py:class:`xml.etree.ElementTree`

        :return: The NML representation of this node.
        :rtype: :py:class:`xml.etree.ElementTree`
        """
        this = self._tree_element(this, parent)

        # Attributes
        for attr_name in self.attributes:
            attr = getattr(self, attr_name)
            if attr is not unset:
                this.attrib[attr_name] = attr

        # Relations
        for relname, relgetter in self.relations.items():

            # Composition elements are tuples
            # Aggregation elements are OrderedDict
            associated = relgetter()
            if isinstance(associated, OrderedDict):
                associated = associated.values()

            # Ignore empty relations
            if not associated or not all(associated):
                continue

            # Create subelement
            relation = etree.SubElement(
                this, 'Relation',
                type='{}#{}'.format(NAMESPACES['nml'], relname)
            )

            for associated in associated:
                etree.SubElement(
                    relation, associated.__class__.__name__,
                    id=associated.identifier
                )

        return this


{% for cls in spec.classes -%}
class {{ cls.name|objectize }}({{ cls.parent|objectize|default('NMLObject', True) }}{%- if cls.abstract -%}, metaclass=ABCMeta{% endif -%}):
    """
    {{ cls.brief|wordwrap(75)|indent(4) }}.

    {{ cls.doc|wordwrap(75)|indent(4) }}.
    {%- if cls.attributes %}
{##}
    {%- endif %}
    {% for attr in cls.attributes -%}
    {{ ':param %s %s: %s.'|format(attr.type, attr.name, attr.doc)|wordwrap(75)|indent(5) }}
    {% endfor -%}
    """
{##}
    {%- if cls.abstract %}
    @abstractmethod
    {%- endif %}
    def __init__(
            {{ 'self%s, **kwargs):'|format(param_attrs(cls.attributes))|wordwrap(67)|indent(12) }}
        super({{ cls.name|objectize }}, self).__init__(**kwargs)
        {%- if cls.attributes %}

        # Attributes
        {%- endif -%}
        {%- for attr in cls.attributes %}

        self.attributes.append('{{ attr.name }}')
        {%- if attr.property %}
        if {{ attr.name }} is {{ attr.default_arg }}:
            {{ attr.name }} = {{ attr.default }}
        self.{{ attr.name }} = {{ attr.name }}
        {%- else %}
        self.{{ attr.name }} = {{ attr.name }}
        {%- endif %}
        {%- endfor %}
        {%- if cls.relations %}
{##}
        # Relations
        {%- endif -%}
        {%- for rel in cls.relations %}
        self.relations['{{ rel.name }}'] = \
            self.get_{{ rel.name|methodize }}
        {%- set relation_collection =  rel.name|variablize + '_' + rel.with.0|pluralize|variablize %}
        self._{{ relation_collection }} = {##}
        {%- if rel.cardinality == '+' -%}
        OrderedDict()
        {%- else -%}
        ({{ 'None, ' * rel.cardinality|int }})
        {%- endif %}
        {%- endfor %}
    {%- for attr in cls.attributes %}
    {%- if attr.property %}

    @property
    def {{ attr.name }}(self):
        """
        Get attribute {{ attr.name }}.

        {{ ':return: %s.'|format(attr.doc)|wordwrap(71)|indent(9) }}
        :rtype: {{ attr.type }}
        """
        return self._{{ attr.name }}

    @{{ attr.name }}.setter
    def {{ attr.name }}(self, {{ attr.name }}):
        """
        Set attribute {{ attr.name }}.

        {{ ':param %s %s: %s.'|format(attr.type, attr.name, attr.doc)|wordwrap(71)|indent(9) }}
        """
        {%- if attr.validation is not none %}
        if {{ attr.name }} is not unset and not {{ attr.validation|format(attr.name) }}:
            raise Attribute{{ attr.nml_attribute|objectize }}Error()
        self._{{ attr.name }} = {{ attr.name }}
        {%- else %}
        self._{{ attr.name }} = {{ attr.name }}
        {%- endif %}
    {%- endif -%}
    {%- endfor -%}
    {%- for rel in cls.relations %}
    {%- set argument = rel.with.0|variablize %}
    {%- set relation_collection =  rel.name|variablize + '_' + rel.with.0|pluralize|variablize %}

    def {{ rel.name|methodize }}(self, {{ argument }}):
        """
        {{ 'Check `%s` relation with given `%s` object.'|format(rel.name, argument)|wordwrap(71)|indent(8) }}

        {{ rel.doc|wordwrap(71)|indent(8) }}.

        {{ ':param %s: Object to validate relation `%s` with.'|format(argument, rel.name)|wordwrap(71)|indent(9) }}
        :type {{ argument }}: {{ rel.with|map('objectize')|join(' or ') }}
        {{ ':return: True if `%s` is related to `self` with `%s`.'|format(argument, rel.name)|wordwrap(71)|indent(9) }}
        :rtype: bool
        """
        if {{ argument }}.__class__ not in (
            {%- for with in rel.with %}
                {{ with|objectize }}{% if not loop.last %},{% endif %}
            {%- endfor %}, ):
            raise Relation{{ rel.name|objectize }}Error()

        return {{ argument }}
        {%- if rel.cardinality == '+' %}.identifier{% endif %} in \
            self._{{ relation_collection }}
    {%- if rel.cardinality == '+' %}

    def add_{{ rel.name|variablize }}(self, {{ argument }}):
        """
        Add given `{{ argument }}` to this object `{{ rel.name }}` relations.

        {{ ':param %s: Object to add to the `%s` relation.'|format(argument, rel.name)|wordwrap(71)|indent(9) }}
        :type {{ argument }}: {{ rel.with|map('objectize')|join(' or ') }}
        """
        if {{ argument }}.__class__ not in (
            {%- for with in rel.with %}
                {{ with|objectize }}{% if not loop.last %},{% endif %}
            {%- endfor %}, ):
            raise Relation{{ rel.name|objectize }}Error()

        self._{{ relation_collection }}[
            {{ argument }}.identifier
        ] = {{ argument }}
    {%- else %}
    {%- if rel.cardinality|int > 1 %}
    {%- set arguments = argument + range(1, rel.cardinality|int + 1)|join(', ' + argument) %}
    {%- else %}
    {%- set arguments = argument %}
    {%- endif %}

    def set_{{ rel.name|variablize }}(self, {{ arguments }}):
        """
        Set the `{{ rel.name }}` relation to given objects.
{##}
        {%- if rel.cardinality|int > 1 %}
        {%- for i in range(1, rel.cardinality|int + 1) %}
        :param {{ argument }}{{ i }}: One of the objects to set the `{{ rel.name }}` relation.
        :type {{ argument }}{{ i }}: {{ rel.with|map('objectize')|join(' or ') }}
        {%- endfor %}
        {%- else %}
        :param {{ argument }}: Object to set to the `{{ rel.name }}` relation.
        :type {{ argument }}: {{ rel.with|map('objectize')|join(' or ') }}
        {%- endif %}
        """
        arg_tuple = ({{ arguments }}, )

        for arg in arg_tuple:
            if arg.__class__ not in ({{ rel.with|map('objectize')|join(', ') }}, ):
                raise Relation{{ rel.name|objectize }}Error()

        {%- if rel.cardinality|int > 1 %}
        if len(set(arg_tuple)) != len(arg_tuple):
            raise Exception('Non unique objects')  # FIXME
        {%- endif %}

        self._{{ relation_collection }} = arg_tuple
    {%- endif %}
{##}
    def get_{{ rel.name|methodize }}(self):
        """
        {{ 'Get all objects related with this object with relation `%s`.'|format(rel.name)|wordwrap(71)|indent(8) }}

        :return: A copy of the collection of objects related with this object.
        :rtype: {% if rel.cardinality == '+' %}:py:class:`OrderedDict`{% else %}set{% endif %}
        """
        return copy(self._{{ relation_collection }})
    {%- endfor %}


{% endfor -%}
__all__ = [
{%- for cls in spec.classes %}
    '{{ cls.name|objectize }}'{% if not loop.last %},{% endif %}
{%- endfor %}
]
